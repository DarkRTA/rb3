PREEXISTING ELEVATOR PITCH LINES
pointers - "computers gotta store stuff somewhere, but they want to be able to use it without copying the entire thing"
virtualization - "you might want base functionality from something and have different variations do different stuff to/from it"
inlining - "sometimes it's faster to do stuff where you are instead of going to the proper place for it"
templates - "you want something done to a bunch of different types of stuff but don't wanna write unique variations"
operator overloading - "sometimes it's nice to be able to do math operations to two things together that aren't just numbers"
structs - "you have a particular object that has several attributes, and want to be able to perform operations on them. for example, I can have a Song struct that has attributes like length, title, artist, and I want to perform operations like play, pause or stop"
classes - "kinda like structs, maybe I don’t want someone to access certain members so easily - like maybe I wrote this Song and I don’t want someone changing the artist member, so I can make it private"
hugh datatype shit - "int: 4 bytes/1 word long: any whole number, positive or negative. if you have an unsigned int, it’s positive numbers only
short: 2 bytes/1 half word: like an int, but due to being half the size, its max value is much smaller
char: 1 byte: like a short, but half the size - typically used to represent ascii characters
bool: 1 byte: either true or false
float: 4 bytes - any decimal number
double: 8 bytes - like a float, but with double the size, it’s got double the precision"


ACTUAL SCRIPT-TYPE THINGS
pointers:
    Computers have memory so they can store things they're not actively using, but sometimes you want something else to use something in memory without copying everything out of memory
    Pointers help alleviate this by just storing a reference to the thing and letting the other thing *de*reference it to get the contents
    For example, if i want to make something that returns two separate values, i could do `float Quadratic_formula(float a, float b, float c, float* output_negative);` where
    the function's returned value is the positive result of the function and the value outputted into `output_negative` is the negative result.
    This would be used like `float positive_result; float negative_result; positive_result = Quadratic_formula(example_a, example_b, example_c, &negative_result);`


data types:
    Computers have a lot of different ways to store different types of data, and it's important to know what differentiates them. Most types are basic whole numbers, but there are exceptions.
    An important concept to grasp is the bit. A bit is just on or off, it can't be either. This is useful because if you string bits together, you can count higher using a base-2 system.
    Bytes are the lingua franca of modern computers. Everything reads and writes using 8-bit bytes, and they string together bytes to make larger types. In C++, the `char` (character) type
    is effectively a user-friendly alias for bytes, and characters are most commonly used for text due to the 7-bit ASCII text standard. Another byte-wide type is the `bool`,
    or boolean numeral. Effectively, it stores either a `true` value or a `false` value, and is very helpful for thing that should only be on or off. Integers are one of the most common
    types, used to represent most whole numbers. At 4 bytes wide, these are generally used for when things need to be at the very least a *bit* big. Short integers, or `short`s, are just
    halfwidth integers. Floating-point numbers are a special kind of data type that uses a special format to define proper decimal numbers, and are very helpful for complex math. A
    `double` is just a twice-wide `float`, and they're good for even more precision than normal.

structs/classes:
    Computers aren't all that intelligent, and the people programming them want to be able to keep relevant data with itself. This is achieved with structured data, or `struct`s. Structs
    pack together data that's used together, and can be used to represent, say, a two-dimensional point on a graph. A simple example would be `struct Point {float x; float y; }`
    Our new struct, Point, can then be used in functions to refer to a singular point. For example, if you wanted to write a simple graphical function, you could have it output an array
    of Points and then display them. A class is an extension of a struct, most commonly used in languages like C++ to define things, or "objects" that you can then operate on. They can
    also hide their contents, if you don't want things to mess with what you have.

op overloading: TODO make stupider
    Every now and again while programming, you think "ugh, i want to be able to make my code more readable by cleaning up the functions without making it impossible to follow". This
    can be achieved with operator overloading, a concept in languages like C++ that allow you to define *what* things like addition and subtraction do under the hood. An example would, say,
    have a class define that, when attempting to multiply a class instance by a number, it should multiply the class' members by that number.


SHIT FROM THE BIG TUTOROL
⌨️ (0:00:00) Introduction
⌨️ (0:01:38) Windows Installation
⌨️ (0:04:54) Mac Installation
⌨️ (0:08:44) Setup & Hello World
⌨️ (0:12:29) Drawing a Shape
⌨️ (0:19:55) Variables
⌨️ (0:31:43) Data Types
⌨️ (0:39:15) Working With Strings
⌨️ (0:49:00) Working With Numbers
⌨️ (0:59:41) Getting User Input
⌨️ (1:05:32) Building a Calculator
⌨️ (1:09:28) Building a Mad Libs
⌨️ (1:13:45) Arrays
⌨️ (1:20:03) Functions
⌨️ (1:29:47) Return Statement
⌨️ (1:35:22) If Statements
⌨️ (1:47:15) If Statements (con't)
⌨️ (1:55:58) Building a Better Calculator
⌨️ (2:02:20) Switch Statements
⌨️ (2:10:47) While Loops
⌨️ (2:18:53) Building a Guessing Game
⌨️ (2:29:18) For Loops
⌨️ (2:38:32) Exponent Function
⌨️ (2:45:21) 2d Arrays & Nested Loops
⌨️ (2:54:55) Comments
⌨️ (2:59:11) Pointers
⌨️ (3:13:26) Classes & Objects
⌨️ (3:25:40) Constructor Functions
⌨️ (3:34:41) Object Functions
⌨️ (3:41:43) Getters & Setters
⌨️ (3:54:04) Inheritance
